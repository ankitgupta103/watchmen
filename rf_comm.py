import sys
import threading
import random
import json
import socket
import time
import threading
import string
import logging

# Local
import constants
import image

from pyrf24 import RF24, RF24_PA_LOW, RF24_PA_HIGH, RF24_PA_MAX, RF24_1MBPS, RF24_250KBPS

radio = RF24(22, 0)
MAX_DATA_SIZE = 32
MAX_CHUNK_SIZE = 19

hname = socket.gethostname()

# This controls the manual acking on unicast (non chunked) messages
ACKING_ENABLED = False
FLAKINESS = 10  # 0-100 %

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s [%(levelname)s] %(message)s',
    handlers=[
        logging.FileHandler('rf_comm.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

"""
MessageID = MSDIII where
  M = message type
  S = SRC (as in HN_ID in constant)
  D = DEST (as in HN_ID in constant, 0 for None)
  III = 3 digit message identifier generated by src

Protocol:
    Any message : MSGID;Payload
    Acknowledgment : <NewID>;MSGID (New ID = ADS...)
        A = acknowledgement
        D to S and a new ID
    Chunk Begin : MSGID;<MESSAGETYPE>CHUNKIDENTIFIER;NUMCHUNKS;MSGMETADATA
    Chunk Begin Ack:
    Chunk Item : MSGID;ChunkIdentifier;ChunkNum;Data
    Chunk End : ChunkIdentifier
    Chunk End Ack: same as acknowledgement
    Chunk Nack : MSGID;CID;NumMissingChunks:Some of the Missing chunks
"""

def get_random_str(n):
    return ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(n))

class RFComm:
    msg_unacked = {} # id -> list of ts
    msg_acked = {} # id -> (tries, timetoack)
    msg_unacked_lock = threading.Lock()
    msg_received = [] # Only for testing
    
    # Sender
    all_chunks_done = {} # cid -> True
    all_chunks_done_lock = threading.Lock()

    def __init__(self, devid):
        self.devid = devid

        # Receiver
        self.msg_chunks_expected = {} # Receiver uses this. cid->num_chunks
        self.msg_chunks_received = {} # Receiver uses this. cid->list of ids got
        self.msg_parts = {} # Receiver uses this. cid->data
        self.msg_processed = []

        # Sender
        self.msg_cunks_missing = {} # CID -> List of ChunkIDs : Sender gets this from ack.
        self.node = None
        self.setup_rf()
        time.sleep(0.5)

    def setup_rf(self):
        if not radio.begin():
            raise RuntimeError("nRF24L01+ not responding")
        radio.printDetails()
        radio.setPALevel(RF24_PA_MAX)
        radio.setDataRate(RF24_250KBPS)
        radio.setChannel(76)
        radio.stop_listening(b"n1")
        radio.open_rx_pipe(1, b"n1")
        radio.payloadSize = MAX_DATA_SIZE

    def add_node(self, node):
        self.node = node
    
    def process_message(self, msgid, mst, msgstr):
        if msgid in self.msg_processed:
            return
        self.msg_processed.append(msgid)
        if len(msgstr) > 100:
            logger.info(f"Processing incoming message : {msgstr[0:100]}...")
        else:
            logger.info(f"Processing incoming message : {msgstr}")
        self.msg_received.append(msgstr)
        if self.node is not None:
            self.node.process_msg(msgid, mst, msgstr)

    def print_status(self):
        with self.msg_unacked_lock:
            logger.info(f"Acked messages = {len(self.msg_acked)}, unacked messages = {len(self.msg_unacked)}")
            logger.info(self.msg_acked)
            logger.info(self.msg_unacked)
            for mi in self.msg_received:
                logger.info(f"Message received at receiver = {mi}")

    # Four kinds of messages:
    # 1. Has a dest, but not for me, ignore
    # 2. Has a dest, and the dest is myself, ack and process.
    # 3. Has no dest, is a broadcast, process, but dont ack.
    # 4. Is an ack, try to unblock my send.
    def _process_read_message(self, msgstr):
        # Handle ack
        msgid, msgpyl = self.sep_part(msgstr, ';')
        (msgtype, src, dest, rid) = self._parse_msg_id(msgid)
        if dest is None or dest == "None":
            logger.info(f"{msgstr} is a broadcast")
            self.process_message(msgid, msgtype, msgpyl)
            return
        if msgtype == constants.MESSAGE_TYPE_ACK and dest == self.devid:
            # print(f" ------------- Received Ack for {msgid} at {time.time() }!!!!!")
            ackid = msgpyl
            if msgpyl[0] == constants.MESSAGE_TYPE_CHUNK_END:
                ackid, remaining = self.sep_part(msgpyl, ':')
                alldone, cid = self.sep_part(remaining, ':')
                if alldone == "ad":
                    logger.info(f" =========== Received ack for {cid} saying receiver got all messages {msgstr}")
                    with self.all_chunks_done_lock:
                        self.all_chunks_done[cid] = True
            with self.msg_unacked_lock:
                if ackid in self.msg_unacked:
                    unack = self.msg_unacked.pop(ackid, None)
                    time_to_ack = time.time() - unack[-1]
                    self.msg_acked[ackid] = (len(unack), time_to_ack)
                    # print(f"{ackid} --- Cleared ack, time for ack = {time_to_ack}")
                else:
                    logger.info(f"Ack {ackid} no matching unacked message")
            return
        if dest != self.devid:
            # print(f"{self.devid} : {msgid} is a unicast but not for me but for {dest}")
            return

        if msgtype == constants.MESSAGE_TYPE_NACK_CHUNK and dest == self.devid:
            parts = msgpyl.split(';')
            if len(parts) != 2:
                logger.error(f"Cant parse {msgpyl}")
                return
            cid = parts[0]
            cliststr = parts[1]
            missing_chunks = [int(x) for x in cliststr.split(",")]
            # TODO remember how many missing at sender
            logger.info(f"Receiver did not get chunks for {cid} : {missing_chunks[0:10]}")
            with self.all_chunks_done_lock:
                for m in missing_chunks:
                    if m not in self.msg_cunks_missing[cid]:
                        self.msg_cunks_missing[cid].append(m)
            # Should this need an ack? TODO
            return
        if msgtype == constants.MESSAGE_TYPE_CHUNK_BEGIN:
            mstcid, numchunkstr = self.sep_part(msgpyl, ';')
            mst = mstcid[0]
            cid = mstcid[1:]
            numchunks = int(numchunkstr)
            self.msg_chunks_expected[cid] = numchunks
            self.msg_chunks_received[cid] = []
            self.msg_parts[cid] = []
            logger.info(f"{cid} from {src} : Sending ack for {msgid} for {numchunks} chunks")
            payload_to_send = msgid
            time.sleep(0.5)
            self._send_unicast(payload_to_send, constants.MESSAGE_TYPE_ACK, src, False, 0)
            return
        if msgtype == constants.MESSAGE_TYPE_CHUNK_ITEM:
            # TODO aggregate by original message id of begin.
            cid, remaining = self.sep_part(msgpyl, ';')
            istr, chunkdata = self.sep_part(remaining, ';')
            i = int(istr)
            r = random.randint(0, 100)
            if r < FLAKINESS:
                return
                # print(f"Flakiness dropping chunk : {i}")
            if cid not in self.msg_chunks_received:
                # We missed chunk begin it seems, ignore this message
                return
            self.msg_chunks_received[cid].append(i)
            self.msg_parts[cid].append((i, chunkdata))
            return
        if msgtype == constants.MESSAGE_TYPE_CHUNK_END:
            cid = msgpyl
            if cid not in self.msg_chunks_expected:
                # We missed chunk begin it seems, ignore this message
                return
            expected_chunks = self.msg_chunks_expected[cid]
            missing_chunks = []
            for i in range(expected_chunks):
                if i not in self.msg_chunks_received[cid]:
                    missing_chunks.append(i)
            logger.info(msgstr)
            if len(missing_chunks) == 0:
                time.sleep(0.5)
                logger.info(f"{cid} from {src} : Sending ack saying I got all chunks for {cid}")
                self._send_unicast(f"{msgid}:ad:{cid}", constants.MESSAGE_TYPE_ACK, src, False, 0)
                self.process_message(msgid, constants.MESSAGE_TYPE_PHOTO, self._recompile_msg(cid))
            else:
                logger.info(f" @@@@@@@ {cid} from {src} At Chunk End missing {len(missing_chunks)} out of {expected_chunks}")
                time.sleep(0.5)
                self._send_missing_chunks(cid, missing_chunks, src)
            # TODO expect at most 5% missing chunks.
            # if len(missing_chunks) == 0:
            #    # Hack this has to be the message type in BEGIN
            #    self._send_unicast(f"{msgid}:ad:{cid}", constants.MESSAGE_TYPE_ACK, src, False, 0)
            #    self.process_message(msgid, constants.MESSAGE_TYPE_PHOTO, self._recompile_msg(cid))
            #else:
            #    # All not done
            #    self._send_unicast(f"{msgid}:and:{cid}", constants.MESSAGE_TYPE_ACK, src, False, 0)
            #    succ = self._send_missing_chunks(cid, missing_chunks, src)
            return
       
        self.process_message(msgid, msgtype, msgpyl)
        # Disable acking except on chunks
        if ACKING_ENABLED:
            logger.info(f"{self.devid} : Sending ack for {msgid} to {src}")
            msg_to_send = msgid
            time.sleep(0.5)
            self._send_unicast(msg_to_send, constants.MESSAGE_TYPE_ACK, src, False, 0)

    def _missing_chunk_helper(self, missing_chunks, strlimit):
        if len(missing_chunks) == 0:
            return []
        chunk_strings = []
        temp_chunk = [str(missing_chunks[0])]
        for i in range(1, len(missing_chunks)):
            c = str(missing_chunks[i])
            temp_chunk.append(c)
            cstr = ",".join(temp_chunk)
            if len(cstr) > strlimit:
                temp_chunk.pop()
                chunk_strings.append(",".join(temp_chunk))
                temp_chunk = [c]
        if len(temp_chunk) > 0:
            chunk_strings.append(",".join(temp_chunk))
        return chunk_strings

    def _send_missing_chunks(self, cid, missing_chunks, dest):
        # 7 for id, 3 for chunk id, 2 for backup :-)
        # TODO this is the place to do error rate
        list_chunks = self._missing_chunk_helper(missing_chunks, 20)
        for chunks_to_send in list_chunks:
            msgstr = f"{cid};{chunks_to_send}"
            succ = self._send_unicast(msgstr, constants.MESSAGE_TYPE_NACK_CHUNK, dest, False, 0)
            if not succ:
                return False
        return True

    def _recompile_msg(self, cid):
        p = sorted(self.msg_parts[cid], key=lambda x: x[0])
        ids = []
        parts = []
        for (cn, d) in p:
            # print(f"{cn} : {d}")
            if cn not in ids:
                ids.append(cn)
                parts.append(d)
        orig_payload = "".join(parts)
        # TODO save intermediate file.
        # TODO image resilience in rebuilding
        return orig_payload
        try:
            logger.info("Checking for json")
            orig_msg = json.loads(orig_payload)
            logger.info("Checking for image")
            if "i_d" in orig_msg:
                logger.info("Seems like an image")
                imstr = orig_msg["i_d"]
                im = image.imstrtoimage(imstr)
                r = get_random_str(3)
                fname = f"/tmp/recompiled_{r}.jpg"
                logger.info(f"Saving image to {fname}")
                im.save(fname)
                # im.show()
        except:
            if len(orig_payload) > 100:
                logger.info(f"Recompiled message =\n{orig_payload[0:100]}")
            else:
                logger.info(f"Recompiled message =\n{orig_payload}")
        return orig_payload

    def _read_from_rf(self):
        radio.listen = True
        logger.info("Starting to receive")
        while True:
            has_payload, pipe = radio.available_pipe()
            if has_payload:
                data = radio.read(MAX_DATA_SIZE)
                try:
                    datastr = data.rstrip(b'\x00').decode("utf-8")
                except Exception as e:
                    logger.error(f"Error reading data : {data} with error {e}")
                self._process_read_message(datastr)
                # print(f"=============== Received data : {datastr}")

    # Non blocking, background thread
    def keep_reading(self):
        # Start background thread to read incoming data
        reader_thread = threading.Thread(target=self._read_from_rf, daemon=True)
        # TODO fix and make it a clean exit on self deletion
        reader_thread.start()

    def _get_msg_id(self, msgtype, dest, override_idstr = None):
        if msgtype == constants.MESSAGE_TYPE_CHUNK_ITEM:
            # No ack needed so no need of ID
            id = f"{msgtype}{self.devid}{dest}"
        else:
            r = get_random_str(3)
            if override_idstr is not None:
                r = override_idstr
            id = f"{msgtype}{self.devid}{dest}{r}"
        return id

    def sep_part(self, msgstr, sepchar):
        firstloc = msgstr.find(sepchar)
        if firstloc < 0:
            return (None, None)
        if firstloc == len(msgstr) - 1:
            return (msgstr[0:firstloc], "")
        else:
            return (msgstr[0:firstloc], msgstr[firstloc+1:])

    def _parse_msg_id(self, msgid):
        if len(msgid) < 3:
            logger.error(f"Failed Parsing Key : {msgid}")
            return None
        msgtype = msgid[0]
        src = msgid[1]
        dest = None
        if msgid[2] != constants.NO_DEST:
            dest = msgid[2]
        rid = None
        if len(msgid) > 3:
            rid = msgid[3:]
        return (msgtype, src, dest, rid)

    def _actual_send(self, msgstr):
        if len(msgstr) > MAX_DATA_SIZE:
            logger.error(f"Message is exceeding length {len(msgstr)} : {msgstr}")
            return False
        # print(f"Sending message : {msgstr}")
        data_bytes = msgstr.encode('utf-8')
        total_len = len(data_bytes)
        buffer = data_bytes.ljust(MAX_DATA_SIZE, b'\x00')
        radio.listen = False
        succ = radio.write(buffer)
        radio.listen = True
        return succ
  
    # No ack, no retry
    def _send_broadcast(self, payload, mst):
        msgid = self._get_msg_id(mst, constants.NO_DEST) # Message type has to improve
        msgstr = f"{msgid};{payload}"
        return self._actual_send(msgstr)

    # dest = None = broadcast, no ack waited, assumed success.
    # dest = IF = unicast, ack awaited with retry_count retries and a 2 sec sleep
    def _send_unicast(self, payload, mst, dest, wait_for_ack = True, retry_count = 3, override_idstr = None):
        msgid = self._get_msg_id(mst, dest, override_idstr) # Message type has to improve
        msgstr = f"{msgid};{payload}"
        if not wait_for_ack:
            return self._actual_send(msgstr)
        # We have to wait for ack.
        sent_succ = False
        for i in range(retry_count):
            if sent_succ:
                break
            logger.info(f"Sending {msgid} for the {i}th time")
            sent_succ = self._send_with_retries(msgstr, msgid)
        return sent_succ

    def _send_chunk_i(self, msg_chunks, cidstr, i, dest):
        num_chunks = len(msg_chunks)
        # print(f"Sending chunk {i} out of {num_chunks}")
        msgid = self._get_msg_id(constants.MESSAGE_TYPE_CHUNK_ITEM, dest)
        payload = f"{cidstr};{i};{msg_chunks[i]}"
        msgstr = f"{msgid};{payload}"
        self._actual_send(msgstr)

    def _send_chunk_end(self, cidstr, dest, alldone):
        payload = cidstr
        if alldone:
            sent = self._send_unicast(payload, constants.MESSAGE_TYPE_CHUNK_END, dest, True, 3, cidstr)
        else:
            sent = self._send_unicast(payload, constants.MESSAGE_TYPE_CHUNK_END, dest, False, 0, cidstr)
        return sent

    def _send_chunk_begin(self, mst, cidstr, num_chunks, dest):
        payload = f"{mst}{cidstr};{num_chunks}"
        sent = self._send_unicast(payload, constants.MESSAGE_TYPE_CHUNK_BEGIN, dest, True, 5)
        return sent

    # Note retry here is separate retry per chunk.
    # We will send 100 chunks, with/without retries, but then the receiver will tell at the end whats missing.
    def _send_chunks(self, msg_chunks, mst, dest, retry_count = 50):
        num_chunks = len(msg_chunks)
        cidstr = get_random_str(3)
        logger.info(f"Getting ready to push {num_chunks} chunks with chunkID = {cidstr}")
        self.msg_cunks_missing[cidstr] = []
        sent = self._send_chunk_begin(mst, cidstr, num_chunks, dest)
        if not sent:
            logger.error(f"Failed to send chunk begin")
            return False
        chunks_undelivered = [i for i in range(len(msg_chunks))]
        alldone = False
        for r in range(retry_count):
            for i in chunks_undelivered:
                self._send_chunk_i(msg_chunks, cidstr, i, dest)
            sent = self._send_chunk_end(cidstr, dest, alldone)
            time.sleep(0.5)
            with self.all_chunks_done_lock:
                chunks_undelivered = self.msg_cunks_missing[cidstr]
                if cidstr in self.all_chunks_done and self.all_chunks_done[cidstr]:
                    alldone = True
            if alldone:
                sent = self._send_chunk_end(cidstr, dest, alldone)
                break
            logger.info(f" {cidstr} to {dest} : After retry count {r} receiver didnt get {len(chunks_undelivered)} which is {chunks_undelivered[0:10]} alldone = {alldone}")
            self.msg_cunks_missing[cidstr] = [] # Reset missing chunks after sending these chunks
            time.sleep(2)
        if alldone:
            logger.info(f" ==== {cidstr} to {dest}: Successfully delivered all chunks !!!")
            return True
        else:
            logger.info(f" **** {cidstr} to {dest} Finally even after all attempts, Could not deliver {len(chunks_undelivered)} chunks : {chunks_undelivered}")
            return False

    def _send_with_retries(self, msgstr, msgid):
        with self.msg_unacked_lock:
             if msgid not in self.msg_unacked:
                 self.msg_unacked[msgid] = [time.time()]
             else:
                 self.msg_unacked[msgid].append(time.time())
        sent_succ = self._actual_send(msgstr)
        ack_received = False
        time_ack_start = time.time_ns()
        while not ack_received:
            with self.msg_unacked_lock:
                if msgid not in self.msg_unacked:
                    logger.info(f" =========== Looks like ack received for {msgid}")
                    return True # Hopefully lock is received
            time.sleep(2)
            ts = time.time_ns()
            # Allow 5 secs for an ack
            if (ts - time_ack_start) > 5000000000:
                logger.info(f" Timed out received for {msgid}")
                break
        return False

    # Note long message cant be a boradcast
    def _send_long_msg(self, long_msg, mst, dest):
        msgstr = long_msg
        msg_chunks = []
        while len(msgstr) > 0:
            msg = msgstr[0:MAX_CHUNK_SIZE]
            msg_chunks.append(msg)
            msgstr = msgstr[MAX_CHUNK_SIZE:]
        logger.info(f"chunking {len(long_msg)} long message into {len(msg_chunks)} chunks")
        t1 = time.time()
        sent = self._send_chunks(msg_chunks, mst, dest, 50)
        t2 = time.time()
        logger.info(f" ********* **  Time taken to deliver {len(msg_chunks)} chunks = {t2-t1}")
        return sent

    def send_message(self, payload, mst, dest):
        if dest is None:
            if len(payload) < 30:
                msg = payload
                self._send_broadcast(msg, mst)
                return True
            else:
                logger.warning(f"Please dont broadcast big messages, this one is of size {len(payload)}")
                return False
        if len(payload) < 30:
            msg = payload
            if ACKING_ENABLED:
                sent = self._send_unicast(msg, mst, dest)
            else:
                sent = self._send_unicast(msg, mst, dest, False, 1)
            return sent
        else:
            logger.warning(f"Too big, will chunk msg {len(payload)}")
            sent = self._send_long_msg(payload, mst, dest)
            return sent

def test_send_img(rf, imgfile, dest):
    mst = constants.MESSAGE_TYPE_PHOTO
    # Allowing json here, since the overhead is worth the metadata.
    im = {"i_m" : "Image metadata",
          "i_d" : image.image2string(imgfile)}
    msgstr = json.dumps(im)
    rf.send_message(msgstr, mst, dest)

def test_send_long_msg(rf, dest):
    mst = constants.MESSAGE_TYPE_SPATH
    long_string = ""
    for i in range(100):
        long_string = long_string + str(i) + "_"
    rf.send_message(long_string, mst, dest)

def test_send_types(rf, devid, dest):
    mst = constants.MESSAGE_TYPE_SPATH
    msg = "Sending a message"
    rf.send_message(msg, mst, None)
    msg = f"Sending a message to {dest}"
    rf.send_message(msg, mst, dest)

# 50 is overhead + size of string of msgsize
def test_send_time_to_ack(rf, dest, msgsize):
    mst = constants.MESSAGE_TYPE_SPATH
    x = "x"*msgsize
    rf.send_message(x, mst, dest)

def main():
    if hname not in constants.HN_ID:
        logger.error(f"Unknown hostname ({hname}) not in {constants.HN_ID}")
        return
    devid = constants.HN_ID[hname]
    rf = RFComm(devid)
    rf.keep_reading()
    if len(sys.argv) > 1:
        # Has dest, send mode
        dest = sys.argv[1]
        # test_send_time_to_ack(rf, dest, 10)
        # test_send_types(rf, devid, dest)
        test_send_long_msg(rf, dest) # Assumes its an image
        test_send_img(rf, "pencil.jpg", dest)
        time.sleep(20)
    else:
        # Keep receiving
        time.sleep(100)
    rf.print_status()

if __name__=="__main__":
    main()
